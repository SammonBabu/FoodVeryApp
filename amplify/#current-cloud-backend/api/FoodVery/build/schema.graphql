
enum TransportationModes {
  DRIVING
  BICYCLING
}

type Courier @aws_iam @aws_api_key {
  id: ID!
  name: String!
  sub: String!
  lat: Float
  lng: Float
  transportationMode: TransportationModes
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type Basket @aws_iam @aws_api_key {
  id: ID!
  BasketDishes(filter: ModelBasketDishFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBasketDishConnection
  userID: ID!
  restaurantID: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

enum OrderStatus {
  NEW
  COOKING
  READY_FOR_PICKUP
  PICKED_UP
  COMPLETED
  DECLINED_BY_RESTAURANT
}

type OrderDish @aws_iam @aws_api_key {
  id: ID!
  quantity: Int!
  Dish: Dish
  orderID: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
  orderDishDishId: ID
}

type Order @aws_iam @aws_api_key {
  id: ID!
  userID: ID!
  Restaurant: Restaurant
  total: Float!
  status: OrderStatus!
  OrderDishes(filter: ModelOrderDishFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelOrderDishConnection
  Courier: Courier
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
  orderRestaurantId: ID
  orderCourierId: ID
}

type BasketDish @aws_iam @aws_api_key {
  id: ID!
  quantity: Int!
  Dish: Dish
  basketID: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
  basketDishDishId: ID
}

type User @aws_iam @aws_api_key {
  id: ID!
  name: String!
  address: String!
  lat: Float!
  lng: Float!
  Orders(filter: ModelOrderFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelOrderConnection
  Baskets(filter: ModelBasketFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBasketConnection
  sub: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type Dish @aws_iam @aws_api_key {
  id: ID!
  name: String!
  image: String
  description: String
  price: Float!
  restaurantID: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type Restaurant @aws_iam @aws_api_key {
  id: ID!
  name: String!
  image: String!
  deliveryFee: Float!
  minDeliveryTime: Int!
  maxDeliveryTime: Int!
  rating: Float
  address: String!
  lat: Float!
  lng: Float!
  Dishes(filter: ModelDishFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelDishConnection
  Baskets(filter: ModelBasketFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBasketConnection
  adminSub: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelCourierConnection @aws_api_key @aws_iam {
  items: [Courier]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelTransportationModesInput {
  eq: TransportationModes
  ne: TransportationModes
}

input ModelCourierFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  sub: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  transportationMode: ModelTransportationModesInput
  and: [ModelCourierFilterInput]
  or: [ModelCourierFilterInput]
  not: ModelCourierFilterInput
}

type Query {
  getCourier(id: ID!): Courier @aws_api_key @aws_iam
  listCouriers(filter: ModelCourierFilterInput, limit: Int, nextToken: String): ModelCourierConnection @aws_api_key @aws_iam
  syncCouriers(filter: ModelCourierFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelCourierConnection @aws_api_key @aws_iam
  getBasket(id: ID!): Basket @aws_api_key @aws_iam
  listBaskets(filter: ModelBasketFilterInput, limit: Int, nextToken: String): ModelBasketConnection @aws_api_key @aws_iam
  syncBaskets(filter: ModelBasketFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelBasketConnection @aws_api_key @aws_iam
  getOrderDish(id: ID!): OrderDish @aws_api_key @aws_iam
  listOrderDishes(filter: ModelOrderDishFilterInput, limit: Int, nextToken: String): ModelOrderDishConnection @aws_api_key @aws_iam
  syncOrderDishes(filter: ModelOrderDishFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelOrderDishConnection @aws_api_key @aws_iam
  getOrder(id: ID!): Order @aws_api_key @aws_iam
  listOrders(filter: ModelOrderFilterInput, limit: Int, nextToken: String): ModelOrderConnection @aws_api_key @aws_iam
  syncOrders(filter: ModelOrderFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelOrderConnection @aws_api_key @aws_iam
  getBasketDish(id: ID!): BasketDish @aws_api_key @aws_iam
  listBasketDishes(filter: ModelBasketDishFilterInput, limit: Int, nextToken: String): ModelBasketDishConnection @aws_api_key @aws_iam
  syncBasketDishes(filter: ModelBasketDishFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelBasketDishConnection @aws_api_key @aws_iam
  getUser(id: ID!): User @aws_api_key @aws_iam
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection @aws_api_key @aws_iam
  syncUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelUserConnection @aws_api_key @aws_iam
  getDish(id: ID!): Dish @aws_api_key @aws_iam
  listDishes(filter: ModelDishFilterInput, limit: Int, nextToken: String): ModelDishConnection @aws_api_key @aws_iam
  syncDishes(filter: ModelDishFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelDishConnection @aws_api_key @aws_iam
  getRestaurant(id: ID!): Restaurant @aws_api_key @aws_iam
  listRestaurants(filter: ModelRestaurantFilterInput, limit: Int, nextToken: String): ModelRestaurantConnection @aws_api_key @aws_iam
  syncRestaurants(filter: ModelRestaurantFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelRestaurantConnection @aws_api_key @aws_iam
}

input ModelCourierConditionInput {
  name: ModelStringInput
  sub: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  transportationMode: ModelTransportationModesInput
  and: [ModelCourierConditionInput]
  or: [ModelCourierConditionInput]
  not: ModelCourierConditionInput
}

input CreateCourierInput {
  id: ID
  name: String!
  sub: String!
  lat: Float
  lng: Float
  transportationMode: TransportationModes
  _version: Int
}

input UpdateCourierInput {
  id: ID!
  name: String
  sub: String
  lat: Float
  lng: Float
  transportationMode: TransportationModes
  _version: Int
}

input DeleteCourierInput {
  id: ID!
  _version: Int
}

type Mutation {
  createCourier(input: CreateCourierInput!, condition: ModelCourierConditionInput): Courier @aws_api_key @aws_iam
  updateCourier(input: UpdateCourierInput!, condition: ModelCourierConditionInput): Courier @aws_api_key @aws_iam
  deleteCourier(input: DeleteCourierInput!, condition: ModelCourierConditionInput): Courier @aws_api_key @aws_iam
  createBasket(input: CreateBasketInput!, condition: ModelBasketConditionInput): Basket @aws_api_key @aws_iam
  updateBasket(input: UpdateBasketInput!, condition: ModelBasketConditionInput): Basket @aws_api_key @aws_iam
  deleteBasket(input: DeleteBasketInput!, condition: ModelBasketConditionInput): Basket @aws_api_key @aws_iam
  createOrderDish(input: CreateOrderDishInput!, condition: ModelOrderDishConditionInput): OrderDish @aws_api_key @aws_iam
  updateOrderDish(input: UpdateOrderDishInput!, condition: ModelOrderDishConditionInput): OrderDish @aws_api_key @aws_iam
  deleteOrderDish(input: DeleteOrderDishInput!, condition: ModelOrderDishConditionInput): OrderDish @aws_api_key @aws_iam
  createOrder(input: CreateOrderInput!, condition: ModelOrderConditionInput): Order @aws_api_key @aws_iam
  updateOrder(input: UpdateOrderInput!, condition: ModelOrderConditionInput): Order @aws_api_key @aws_iam
  deleteOrder(input: DeleteOrderInput!, condition: ModelOrderConditionInput): Order @aws_api_key @aws_iam
  createBasketDish(input: CreateBasketDishInput!, condition: ModelBasketDishConditionInput): BasketDish @aws_api_key @aws_iam
  updateBasketDish(input: UpdateBasketDishInput!, condition: ModelBasketDishConditionInput): BasketDish @aws_api_key @aws_iam
  deleteBasketDish(input: DeleteBasketDishInput!, condition: ModelBasketDishConditionInput): BasketDish @aws_api_key @aws_iam
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
  createDish(input: CreateDishInput!, condition: ModelDishConditionInput): Dish @aws_api_key @aws_iam
  updateDish(input: UpdateDishInput!, condition: ModelDishConditionInput): Dish @aws_api_key @aws_iam
  deleteDish(input: DeleteDishInput!, condition: ModelDishConditionInput): Dish @aws_api_key @aws_iam
  createRestaurant(input: CreateRestaurantInput!, condition: ModelRestaurantConditionInput): Restaurant @aws_api_key @aws_iam
  updateRestaurant(input: UpdateRestaurantInput!, condition: ModelRestaurantConditionInput): Restaurant @aws_api_key @aws_iam
  deleteRestaurant(input: DeleteRestaurantInput!, condition: ModelRestaurantConditionInput): Restaurant @aws_api_key @aws_iam
}

type Subscription {
  onCreateCourier: Courier @aws_subscribe(mutations: ["createCourier"]) @aws_api_key @aws_iam
  onUpdateCourier: Courier @aws_subscribe(mutations: ["updateCourier"]) @aws_api_key @aws_iam
  onDeleteCourier: Courier @aws_subscribe(mutations: ["deleteCourier"]) @aws_api_key @aws_iam
  onCreateBasket: Basket @aws_subscribe(mutations: ["createBasket"]) @aws_api_key @aws_iam
  onUpdateBasket: Basket @aws_subscribe(mutations: ["updateBasket"]) @aws_api_key @aws_iam
  onDeleteBasket: Basket @aws_subscribe(mutations: ["deleteBasket"]) @aws_api_key @aws_iam
  onCreateOrderDish: OrderDish @aws_subscribe(mutations: ["createOrderDish"]) @aws_api_key @aws_iam
  onUpdateOrderDish: OrderDish @aws_subscribe(mutations: ["updateOrderDish"]) @aws_api_key @aws_iam
  onDeleteOrderDish: OrderDish @aws_subscribe(mutations: ["deleteOrderDish"]) @aws_api_key @aws_iam
  onCreateOrder: Order @aws_subscribe(mutations: ["createOrder"]) @aws_api_key @aws_iam
  onUpdateOrder: Order @aws_subscribe(mutations: ["updateOrder"]) @aws_api_key @aws_iam
  onDeleteOrder: Order @aws_subscribe(mutations: ["deleteOrder"]) @aws_api_key @aws_iam
  onCreateBasketDish: BasketDish @aws_subscribe(mutations: ["createBasketDish"]) @aws_api_key @aws_iam
  onUpdateBasketDish: BasketDish @aws_subscribe(mutations: ["updateBasketDish"]) @aws_api_key @aws_iam
  onDeleteBasketDish: BasketDish @aws_subscribe(mutations: ["deleteBasketDish"]) @aws_api_key @aws_iam
  onCreateUser: User @aws_subscribe(mutations: ["createUser"]) @aws_api_key @aws_iam
  onUpdateUser: User @aws_subscribe(mutations: ["updateUser"]) @aws_api_key @aws_iam
  onDeleteUser: User @aws_subscribe(mutations: ["deleteUser"]) @aws_api_key @aws_iam
  onCreateDish: Dish @aws_subscribe(mutations: ["createDish"]) @aws_api_key @aws_iam
  onUpdateDish: Dish @aws_subscribe(mutations: ["updateDish"]) @aws_api_key @aws_iam
  onDeleteDish: Dish @aws_subscribe(mutations: ["deleteDish"]) @aws_api_key @aws_iam
  onCreateRestaurant: Restaurant @aws_subscribe(mutations: ["createRestaurant"]) @aws_api_key @aws_iam
  onUpdateRestaurant: Restaurant @aws_subscribe(mutations: ["updateRestaurant"]) @aws_api_key @aws_iam
  onDeleteRestaurant: Restaurant @aws_subscribe(mutations: ["deleteRestaurant"]) @aws_api_key @aws_iam
}

type ModelBasketConnection @aws_api_key @aws_iam {
  items: [Basket]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelBasketFilterInput {
  id: ModelIDInput
  userID: ModelIDInput
  restaurantID: ModelIDInput
  and: [ModelBasketFilterInput]
  or: [ModelBasketFilterInput]
  not: ModelBasketFilterInput
}

input ModelBasketConditionInput {
  userID: ModelIDInput
  restaurantID: ModelIDInput
  and: [ModelBasketConditionInput]
  or: [ModelBasketConditionInput]
  not: ModelBasketConditionInput
}

input CreateBasketInput {
  id: ID
  userID: ID!
  restaurantID: ID!
  _version: Int
}

input UpdateBasketInput {
  id: ID!
  userID: ID
  restaurantID: ID
  _version: Int
}

input DeleteBasketInput {
  id: ID!
  _version: Int
}

type ModelOrderDishConnection @aws_api_key @aws_iam {
  items: [OrderDish]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelOrderDishFilterInput {
  id: ModelIDInput
  quantity: ModelIntInput
  orderID: ModelIDInput
  and: [ModelOrderDishFilterInput]
  or: [ModelOrderDishFilterInput]
  not: ModelOrderDishFilterInput
  orderDishDishId: ModelIDInput
}

input ModelOrderDishConditionInput {
  quantity: ModelIntInput
  orderID: ModelIDInput
  and: [ModelOrderDishConditionInput]
  or: [ModelOrderDishConditionInput]
  not: ModelOrderDishConditionInput
  orderDishDishId: ModelIDInput
}

input CreateOrderDishInput {
  id: ID
  quantity: Int!
  orderID: ID!
  _version: Int
  orderDishDishId: ID
}

input UpdateOrderDishInput {
  id: ID!
  quantity: Int
  orderID: ID
  _version: Int
  orderDishDishId: ID
}

input DeleteOrderDishInput {
  id: ID!
  _version: Int
}

type ModelOrderConnection @aws_api_key @aws_iam {
  items: [Order]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelOrderStatusInput {
  eq: OrderStatus
  ne: OrderStatus
}

input ModelOrderFilterInput {
  id: ModelIDInput
  userID: ModelIDInput
  total: ModelFloatInput
  status: ModelOrderStatusInput
  and: [ModelOrderFilterInput]
  or: [ModelOrderFilterInput]
  not: ModelOrderFilterInput
  orderRestaurantId: ModelIDInput
  orderCourierId: ModelIDInput
}

input ModelOrderConditionInput {
  userID: ModelIDInput
  total: ModelFloatInput
  status: ModelOrderStatusInput
  and: [ModelOrderConditionInput]
  or: [ModelOrderConditionInput]
  not: ModelOrderConditionInput
  orderRestaurantId: ModelIDInput
  orderCourierId: ModelIDInput
}

input CreateOrderInput {
  id: ID
  userID: ID!
  total: Float!
  status: OrderStatus!
  _version: Int
  orderRestaurantId: ID
  orderCourierId: ID
}

input UpdateOrderInput {
  id: ID!
  userID: ID
  total: Float
  status: OrderStatus
  _version: Int
  orderRestaurantId: ID
  orderCourierId: ID
}

input DeleteOrderInput {
  id: ID!
  _version: Int
}

type ModelBasketDishConnection @aws_iam @aws_api_key {
  items: [BasketDish]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelBasketDishFilterInput {
  id: ModelIDInput
  quantity: ModelIntInput
  basketID: ModelIDInput
  and: [ModelBasketDishFilterInput]
  or: [ModelBasketDishFilterInput]
  not: ModelBasketDishFilterInput
  basketDishDishId: ModelIDInput
}

input ModelBasketDishConditionInput {
  quantity: ModelIntInput
  basketID: ModelIDInput
  and: [ModelBasketDishConditionInput]
  or: [ModelBasketDishConditionInput]
  not: ModelBasketDishConditionInput
  basketDishDishId: ModelIDInput
}

input CreateBasketDishInput {
  id: ID
  quantity: Int!
  basketID: ID!
  _version: Int
  basketDishDishId: ID
}

input UpdateBasketDishInput {
  id: ID!
  quantity: Int
  basketID: ID
  _version: Int
  basketDishDishId: ID
}

input DeleteBasketDishInput {
  id: ID!
  _version: Int
}

type ModelUserConnection @aws_api_key @aws_iam {
  items: [User]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelUserFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  address: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  sub: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

input ModelUserConditionInput {
  name: ModelStringInput
  address: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  sub: ModelStringInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
}

input CreateUserInput {
  id: ID
  name: String!
  address: String!
  lat: Float!
  lng: Float!
  sub: String!
  _version: Int
}

input UpdateUserInput {
  id: ID!
  name: String
  address: String
  lat: Float
  lng: Float
  sub: String
  _version: Int
}

input DeleteUserInput {
  id: ID!
  _version: Int
}

type ModelDishConnection @aws_api_key @aws_iam {
  items: [Dish]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelDishFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  image: ModelStringInput
  description: ModelStringInput
  price: ModelFloatInput
  restaurantID: ModelIDInput
  and: [ModelDishFilterInput]
  or: [ModelDishFilterInput]
  not: ModelDishFilterInput
}

input ModelDishConditionInput {
  name: ModelStringInput
  image: ModelStringInput
  description: ModelStringInput
  price: ModelFloatInput
  restaurantID: ModelIDInput
  and: [ModelDishConditionInput]
  or: [ModelDishConditionInput]
  not: ModelDishConditionInput
}

input CreateDishInput {
  id: ID
  name: String!
  image: String
  description: String
  price: Float!
  restaurantID: ID!
  _version: Int
}

input UpdateDishInput {
  id: ID!
  name: String
  image: String
  description: String
  price: Float
  restaurantID: ID
  _version: Int
}

input DeleteDishInput {
  id: ID!
  _version: Int
}

type ModelRestaurantConnection @aws_api_key @aws_iam {
  items: [Restaurant]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelRestaurantFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  image: ModelStringInput
  deliveryFee: ModelFloatInput
  minDeliveryTime: ModelIntInput
  maxDeliveryTime: ModelIntInput
  rating: ModelFloatInput
  address: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  adminSub: ModelStringInput
  and: [ModelRestaurantFilterInput]
  or: [ModelRestaurantFilterInput]
  not: ModelRestaurantFilterInput
}

input ModelRestaurantConditionInput {
  name: ModelStringInput
  image: ModelStringInput
  deliveryFee: ModelFloatInput
  minDeliveryTime: ModelIntInput
  maxDeliveryTime: ModelIntInput
  rating: ModelFloatInput
  address: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  adminSub: ModelStringInput
  and: [ModelRestaurantConditionInput]
  or: [ModelRestaurantConditionInput]
  not: ModelRestaurantConditionInput
}

input CreateRestaurantInput {
  id: ID
  name: String!
  image: String!
  deliveryFee: Float!
  minDeliveryTime: Int!
  maxDeliveryTime: Int!
  rating: Float
  address: String!
  lat: Float!
  lng: Float!
  adminSub: String
  _version: Int
}

input UpdateRestaurantInput {
  id: ID!
  name: String
  image: String
  deliveryFee: Float
  minDeliveryTime: Int
  maxDeliveryTime: Int
  rating: Float
  address: String
  lat: Float
  lng: Float
  adminSub: String
  _version: Int
}

input DeleteRestaurantInput {
  id: ID!
  _version: Int
}

